<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>👨🏻‍💻 技术 on Kiki&#39;s Blog</title>
    <link>https://www.atomicbot.cloud/posts/tech/</link>
    <description>Recent content in 👨🏻‍💻 技术 on Kiki&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 20 Oct 2022 13:35:26 +0800</lastBuildDate><atom:link href="https://www.atomicbot.cloud/posts/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring Cloud Feign &amp;&amp; Seata At模式分布式事务实践</title>
      <link>https://www.atomicbot.cloud/posts/tech/seata_at%E6%A8%A1%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 20 Oct 2022 13:35:26 +0800</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/seata_at%E6%A8%A1%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E8%B7%B5/</guid>
      <description>演示案例架构图 中间件服务构建 根据SpringCloudAlibaba与SpringCloud的对应关系,本次案例实现采用中间件/框架版本如下 Spring Boot: 2.6.13 Spring Cloud: 2021.0.5 Spring Cloud Alibaba: 2021.0.5.0 Nacos: 2.2.0 Seata: 1.6.1 Mysql: 8.1.0 Nacos构建 从这里下载Nacos预编译包,nacos配置数据我们采用持久化到数据库的方式 首先准备nacos</description>
    </item>
    
    <item>
      <title>Spring Cloud Feign在异步接口执行的过程中传递请求头Token</title>
      <link>https://www.atomicbot.cloud/posts/tech/springcloudfeign%E5%9C%A8%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BC%A0%E9%80%92%E8%AF%B7%E6%B1%82%E5%A4%B4token/</link>
      <pubDate>Mon, 24 Jan 2022 13:37:21 +0800</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/springcloudfeign%E5%9C%A8%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BC%A0%E9%80%92%E8%AF%B7%E6%B1%82%E5%A4%B4token/</guid>
      <description>Spring Cloud Feign 在异步接口执行的过程中传递请求头Token 业务流程 用户发起请求后,在A服务中执行业务逻辑,执行过程中需要调用其他微服务B进行流程审批,简单方式是在A服务中所有逻辑(1,2,3)采用同步逻辑放在一个事务中,但是如果调用B服务的过程中,处理逻辑很复杂,会导致A服务的请求一直阻塞</description>
    </item>
    
    <item>
      <title>Redis高可用之集群模式</title>
      <link>https://www.atomicbot.cloud/posts/tech/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 29 Jun 2020 10:35:26 +0000</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>背景 Redis的主从、哨兵这2中高可用模式已经解决了Redis实例发生故障时的自动主备切换,保证了服务的高可用 但是这只是解决了服务的可靠性,随着业务不断增长,并发量提升,原有的主从架构已经无法满足性能要求了,这时会出现一些问题: 单机的物理性能达到极限,不能无限承受流量增加 超额请求</description>
    </item>
    
    <item>
      <title>Redis高可用之哨兵模式</title>
      <link>https://www.atomicbot.cloud/posts/tech/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 23 Jun 2020 21:23:11 +0000</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</guid>
      <description>背景 Redis主从模式由于是读写分离的模式,可以大幅提高性能和服务的可用性,减少甚至避免Redis服务发生宕机的可能,主从模式的主要能力如下: 故障隔离和恢复: 无论主节点或者从节点崩溃,其他节点仍然可以正常提供服务(主节点崩溃时,无法提供写服务,需要手动切换主从) 读写分离:主节点负</description>
    </item>
    
    <item>
      <title>Redis高可用之主从模式</title>
      <link>https://www.atomicbot.cloud/posts/tech/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 21 Jun 2020 20:00:19 +0000</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/</guid>
      <description>主从复制介绍 Redis的RDB和AOF持久化机制,只是解决了Redis服务崩溃后的快速恢复数据,但是并没有减少或者降低Redis服务崩溃的可能性,也就是没有提高Redis服务的高可用性. 目前Redis实现高可用服务主要有三种方式: 主从模式、哨兵模式、集群模式.首先来说主从模式. R</description>
    </item>
    
    <item>
      <title>分布式算法之--一致性hash算法.md</title>
      <link>https://www.atomicbot.cloud/posts/tech/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E4%B9%8B-%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 21 Jun 2020 19:22:09 +0000</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E4%B9%8B-%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</guid>
      <description>介绍</description>
    </item>
    
    <item>
      <title>Redis的数据持久化</title>
      <link>https://www.atomicbot.cloud/posts/tech/redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
      <pubDate>Fri, 19 Jun 2020 13:35:26 +0000</pubDate>
      
      <guid>https://www.atomicbot.cloud/posts/tech/redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
      <description>介绍 Redis通常用来作为应用程序与数据库DB之间的一层缓存中间件,来保证数据的访问效率,那既然是一层中间件,必然存在宕机、崩溃的问题,一旦Redis服务不可用,可能产生的后果包括: Redis进程中保存的数据全部丢失,引文Redis数据是存在RAM中的 数据访问从内存级别降低至IO</description>
    </item>
    
  </channel>
</rss>

<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-11-13T21:18:07.4751635"><meta name="build-number" content="${buildNumber}">       <title>异步接口执行的过程中发起Feign调用 | 帽子反戴 单手炒菜</title><script id="virtual-toc-data" type="application/json">[{"id":"fa485267_230","level":0,"title":"业务流程","anchor":"#fa485267_230"},{"id":"fa485267_235","level":0,"title":"解决方案","anchor":"#fa485267_235"},{"id":"fa485267_241","level":0,"title":"实际操作","anchor":"#fa485267_241"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="异步接口执行的过程中发起Feign调用 | 帽子反戴 单手炒菜"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="帽子反戴 单手炒菜 Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="springcloudfeign-token.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="异步接口执行的过程中发起Feign调用 | 帽子反戴 单手炒菜"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "springcloudfeign-token.html#webpage", "url": "springcloudfeign-token.html", "name": "异步接口执行的过程中发起Feign调用 | 帽子反戴 单手炒菜", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "帽子反戴 单手炒菜 Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="SpringCloudFeign在异步接口执行的过程中传递请求头Token" data-main-title="异步接口执行的过程中发起Feign调用" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Spring.md|Spring///Spring-Cloud.md|Spring Cloud"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>帽子反戴 单手炒菜  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="SpringCloudFeign在异步接口执行的过程中传递请求头Token"  id="SpringCloudFeign在异步接口执行的过程中传递请求头Token.md"  >异步接口执行的过程中发起Feign调用</h1>  <section class="chapter"><h2 id="fa485267_230" data-toc="fa485267_230">业务流程</h2><aside class="prompt" data-type="tip" data-title="" id="fa485267_231"><p id="fa485267_232">用户发起请求后,在A服务中执行业务逻辑,执行过程中需要调用其他微服务B进行流程审批,简单方式是在A服务中所有逻辑(1,2,3)采用同步逻辑放在一个事务中,但是如果调用B服务的过程中,处理逻辑很复杂,会导致A服务的请求一直阻塞,用户体验很不好</p></aside><figure  id="fa485267_233"><img alt="image-20231024110959505" title="image-20231024110959505" src="https://fanzhengxiang.oss-cn-chengdu.aliyuncs.com/blog-img/image-20231024110959505.png"  class=""  /></figure><p id="fa485267_234">优化后的逻辑为将第2步,调整为异步逻辑,异步调用服务B,可以使A服务快速完成逻辑处理,相应用户,B服务在流程发起成功之后,再回调A服务,回写流程发起的结果(流程发起成功或者流程发起失败的原因),此时就引申出一个问题: 在异步调用时,feign接口的请求会丢失掉请求头中的Token,导致在调用服务B时出现401</p></section><section class="chapter"><h2 id="fa485267_235" data-toc="fa485267_235">解决方案</h2><aside class="prompt" data-type="tip" data-title="" id="fa485267_236"><p id="fa485267_237">网上大多数的解决办法都是抄来抄去使用拦截器方式实现,不推荐,我这里采用的是Feign官方的解决方案,Feign Builder</p></aside><p id="fa485267_238"><a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html" id="fa485267_239"   data-external="true" rel="noopener noreferrer" >手动创建Feign Client</a></p><figure  id="fa485267_240"><img alt="image-20231024112012585" title="image-20231024112012585" src="https://fanzhengxiang.oss-cn-chengdu.aliyuncs.com/blog-img/image-20231024112012585.png"  class=""  /></figure></section><section class="chapter"><h2 id="fa485267_241" data-toc="fa485267_241">实际操作</h2><p id="fa485267_242">微服务B现有的Feign接口如下:</p><div class="code-block" data-lang="java"         >


@FeignClient(
    name = &quot;eip-bpm-runtime&quot;,
    url = &quot;${eip-bpm-runtime:}&quot;,
    fallbackFactory = FlowApiFallback.class
)
public interface FlowApi {
  
    @RequestMapping(
        value = {&quot;/flow/instance/v1/start&quot;},
        method = {RequestMethod.POST},
        produces = {&quot;application/json; charset=utf-8&quot;}
    )
    ObjectNode start(@RequestBody JSONObject var1) throws Exception;

}

</div><p id="fa485267_244">现在需要在A服务中手动创建一个<code class="code" id="fa485267_245">FlowApi</code>的实例发起调用</p><p id="fa485267_246">首先在A服务中创建一个配置类</p><div class="code-block" data-lang="java"         >


import com.aliyun.openservices.shade.com.alibaba.fastjson.support.spring.FastJsonJsonView;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.hotent.api.FlowApi;
import feign.Client;
import feign.Feign;
import org.apache.http.HttpHeaders;
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringDecoder;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.cloud.openfeign.support.SpringMvcContract;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

/**
 * BPM 异步feign请求头设置
 *
 * @author kiki
 * @date 2022/1/13 14:25
 * @since 0.0.1
 */
@Component
public class BpmFlowApiConfig {

    @Resource
    private Client client;

    /**
     * 接口请求path
     */
    private String url;

    public void setUrl(String url) {
        this.url = url;
    }

    public FlowApi flowApiClient(String accessToken){
        HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter(new ObjectMapper());
        ObjectFactory&lt;HttpMessageConverters&gt; converter = () -&gt; new HttpMessageConverters(jsonConverter);
        return Feign.builder().client(client)
                .encoder(new SpringEncoder(converter))
                .decoder(new SpringDecoder(converter))
                .contract(new SpringMvcContract())
                .requestInterceptor(template -&gt; template.header(org.springframework.http.HttpHeaders.AUTHORIZATION, accessToken))
                .requestInterceptor(template -&gt; template.header(HttpHeaders.CONTENT_TYPE, FastJsonJsonView.DEFAULT_CONTENT_TYPE))
                .target(FlowApi.class, url);

    }
}

</div><p id="fa485267_248">然后在需要发起对B服务调用的地方注入该配置类,并手动构建Feign客户端发起调用</p><div class="code-block" data-lang="java"         >
/**
 * desc
 *
 * @author kiki
 * @date 2022/1/13 11:37
 * @since 0.0.1
 */
@Service
@Slf4j
public class IAsyncServiceImpl implements IAsyncService {

    /**
     * 目标微服务的服务名称
     * 
     */
    @Value(&quot;${bpm.url:http://eip-bpm-runtime/}&quot;)
    private String flowApiUrl;

    @Resource
    private BpmFlowApiConfig bpmFlowApiConfig;


    /**
     * 异步上传发票并发起审批
     *
     * @param paymentAddEo 请求参数
     * @param header 上游请求的Token
     */
    @Async
    @Override
    public void uploadInvoicesAndStartBpmProcess(PaymentBillAddReqDto paymentAddEo, String header) {
        // TODO A服务的自身业务逻辑...
         startNewBpmProcess(paymentAddEo, fileIdList, header);
        // TODO A服务的自身后续业务逻辑...
       
    }

    private void startNewBpmProcess(PaymentBillAddReqDto paymentAddEo, List&lt;String&gt; fileIdList, String header) {
        try {
            // ...省略业务逻辑
            log.info(&quot;{}发起bpm申请流程参数：{}&quot;, paymentBillDesc, paramStr);
            // 这里是发起调用配置的关键
            // 1.设置调用服务的服务名
            // 2.手动为Feign Client设置header(token)
            bpmFlowApiConfig.setUrl(flowApiUrl);
            start = bpmFlowApiConfig.flowApiClient(header).start(JSON.parseObject(paramStr));
            ObjectMapper objectMapper = new ObjectMapper();
            String resultStr = objectMapper.writeValueAsString(start);
            log.info(&quot;{}发起BPM审批请求结果：{}&quot;, paymentBillDesc, resultStr);
            // ...省略业务逻辑
            bpmProcessService.add(reqDto);
        } catch (Exception e) {
            log.error(&quot;{}失败，bpm返回信息{}，保存的流程信息{}，错误信息：{}&quot;, paymentBillDesc, JSON.toJSONString(start), JSONObject.toJSONString(paymentAddEo, SerializerFeature.PrettyFormat), e);
            throw new BizException(String.format(&quot;%s发起BPM审批失败！&quot;, e.getMessage()));
        }
    }
}

</div><p id="fa485267_250">其中,A服务在请求发起时,传递的Token需要在A服务发起调用前事先获取</p><div class="code-block" data-lang="java"         >
ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
HttpServletRequest request = requestAttributes.getRequest();
String accessToken = request.getHeader(&quot;Access-Token&quot;);
</div></section><div class="last-modified"> Last modified: 13 十一月 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="spring-cloud.html">Spring Cloud</a>   <a class="navigation-links__next" href="seata-at.html">Seata_At模式分布式事务实践</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>